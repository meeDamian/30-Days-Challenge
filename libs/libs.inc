<?
    /*
     * ALL REQUIRED PHP CONSTANTS
     * WHICH ARE USED MORE THAN ONCE
     */
    define("EMAIL_REGEXP", "^((?:(?:(?:\w[\.\-\+]?)*)\w)+)\@((?:(?:(?:\w[\.\-\+]?){0,62})\w)+)\.(\w{2,6})$");

     /*
     * ALL REQUIRED PHP LIBRARIES
     * WHICH ARE USED MORE THAN ONCE
     */

/** set header mime type **
 * SETS PROPER HEADER (MOSTLY FOR AJAX RESPONSES)
 * ex. header('json');
 **
 * $type (string) => what kind of header should be set
 *  - json      : used for most json responses
 *  - html      : used when html chunk of code is being returned
 *  - script    : used when JS scripts are being loaded
 *  - text      : used in every other case (plain text is used)
 **
 * returns nothing;
 * > sets proper html headers and passes execution further
 **/
function head($type="text") {
    switch(strtolower($type)) {
        case 'json': header('Content-Type: application/json; charset=utf-8'); break;
        case 'script': header('Content-Type: application/javascript; charset=utf-8'); break;
        case 'html': header('Content-Type: text/html; charset=utf-8'); break;
        default: header('Content-Type: text/plain; charset=utf-8'); break;
    }
}

/** respond **
 * RESPOND WITH VALID JSON STRING (FROM AJAX)
 * ex. respond(true, "everything ok", array('id'=>"some_id",'name'=>'some_name'));
 **
 * $success (bool)   => if AJAX operation succeded
 * $cause   (string) => very quick explanation: "<type> <operation> <operation parameter>" (ex. "mysql insert user")
 * $more    (array)  => any additional info that can be usefull
 **
 * returns nothing;
 * > exits execution and prints JSON
 **/
function respond($success, $cause, $more="") { // respond with normalized JSON format from all files requested by ajax and log it in meantime
    exit(json_encode(toLog(array('success'=>$success,'cause'=>$cause,'more'=>$more),"ajax")));
}

/** utf-8 **
 * WORD WRAP FOR UTF-8 STRINGS
 **
 * $str   (string)  => string to be wrapped
 * $width (integer) => how often to cut
 * $break (string)  => what to insert in breaks
 * $cut   (boolean) => should function cut words
 **
 * returns cutted string
 **/
function ww_utf8($str, $width, $break, $cut = false) { // word-wrap for utf-8 text
    if(!$cut) $regexp = '#^(?:[\x00-\x7F]|[\xC0-\xFF][\x80-\xBF]+){'.$width.',}\b#U';
    else      $regexp = '#^(?:[\x00-\x7F]|[\xC0-\xFF][\x80-\xBF]+){'.$width.'}#';

    if (function_exists('mb_strlen')) $str_len = mb_strlen($str,'UTF-8');
    else $str_len = preg_match_all('/[\x00-\x7F\xC0-\xFD]/', $str, $var_empty);

    $while_what = ceil($str_len / $width);
    $i = 1;
    $return = '';
    while($i < $while_what) {
        preg_match($regexp, $str,$matches);
        $string = $matches[0];
        $return .= $string.$break;
        $str = substr($str, strlen($string));
        $i++;
    }
    return $return.$str;
}

/** log **
 * LOGGING FUNCTION
 * ex. toLog("User $user have logged in successfully", 'user');
 **
 * $str  => string to be logged
 * $type => type of logging:
 *  - access: all non-error ACTIONS generated by users
 *  - user  : same as 'access'
 *  - error : all possible ERRORS generated by users
 *  - admin : all important access/error actions generated by ADMIN
 *  - ajax  : all ajax actions (invoked from PHP:respond() and JS:log() )
 **
 * returns given string
 **/
function toLog($str, $type="access") { // log given string of given type (optional: for given user)

    $log_path = dirname(__DIR__);

    switch( $type ) {
        case 'error':
            $fname = 'err.log'; break;
        default:
        case 'access':
        case 'user':
            $fname = 'general.log'; break;
        case 'admin':
            $fname = 'admin.log'; break;
        case 'ajax':
            // TODO: fix output format of presented ajax requests
            $fname = 'ajax.log'; break;
    }

    $log_str = date('[Y-m-d H:i:s]') . " " . preg_replace('/\s+/', ' ', str_replace("\n", "", ((is_array($str)) ? print_r($str, true) : $str ) )).", ip => " . getIP() . ", user-agent => " . $_SERVER['HTTP_USER_AGENT'] . "\n";

    // save to general log files
    $f = fopen($log_path . "/log/" . $fname, "a+");
    fwrite($f, $log_str);
    fclose($f);

    // return logged string
    return $str;
}

/** ip **
 * GETS CURRENT USER IP
 **
 * returns ip of current user
 **/
function getIP() { // get IP of current connection; called from toLog
    $ip = (empty($_SERVER['HTTP_CLIENT_IP']) ?
        (empty($_SERVER['HTTP_X_FORWARDED_FOR']) ?
            $_SERVER['REMOTE_ADDR'] : $_SERVER['HTTP_X_FORWARDED_FOR']) : $_SERVER['HTTP_CLIENT_IP']);
    return str_replace("unknown, ", "", $ip);
}

/** safe superglobal tables **
 * RETURNS AND CACHES SAFE CONTENT OF SUPERGLOBAL TABLES (POST, GET, COOKIE, REQUEST)
 * ex. __('password','mysql','post');
 **
 * $name => index from tables
 * $dest => [vel destination] states where data is destined to get (html|xml|mysql|sql|json|none); case insensitive
 *  - passing "none", false or empty string will return original string
 *  - to use mysql mysql connection must 
 * $type => which table to use (post|p|get|g|cookie|c|request|r); 'request' is default; case insensitive
 **
 * returns string safe to use in $dest or false if destination is empty
 */
function __($name,$dest=false,$type="REQUEST") {

    // figre out where from to retreive data
    $_type = array('P'=>'POST','G'=>'GET','C'=>'COOKIE','R'=>'REQUEST','V'=>'VARIABLE'); // TODO: should other arrays be added?
    if(strlen(($type=strtoupper($type)))==1 and $_type[$type]!="") $type=$_type[$type]; // if shortcut provided - change it to full-name
    elseif(!in_array($type,$_type)) $type="REQUEST"; // if fullname isn't in array - set default type

    // retreive data (if unset set data and dest to false, so function returns false)
    if( ini_get('auto_globals_jit') and $type == "REQUEST") $data = isset($_REQUEST[$name]) ? $_REQUEST[$name] : ($dest = false); // if php won't see $_REQUEST in $GLOBALS
    elseif($type=="VARIABLE") $data = isset($$name) ? $$name : ($dest = false); // if VARIABLE requested (they're not in $GLOBALS either)
    else $data = isset($GLOBALS[($type="_$type")][$name]) ? $GLOBALS[$type][$name] : ($dest = false); // everything else

    //proceed with data
    switch( strtolower($dest) ) {
        case 'html':
        case 'xml':
        case '*ml':
            return htmlspecialchars($data, ENT_QUOTES, "UTF-8");

        case 'mysql':
        case 'sql':
        case '*sql':
            // encode for mysql
            return mysql_real_escape_string($data);

        case 'json':
            // does json needs any encoding?
            return json_encode($data);

        default:
            return $data;
    }
}

/** checks if user is logged in **
 *
 **/
function is_logged() {
    // performs check whether user is logged in;
    // if so returns true and sets proper values to user info array
    // else returns false and clears user info array (in case)
}

/** generates hash **
 * RETURNS NOT-REALLY-EASY-TO-BREAK HASH OF A PASSWORD
 * ex. make_hash('mySuper5ecur3Pa5S', '346e503849063f5123f11750120dc787cd2c336c', 'damian.wasilewski@gmail.com');
 **
 * $pass => password provided by user
 * $salt => salt generated for each user individually (random sha1 hash)
 * $email => user's current email (remember to regenerate hash when password changes)
 * $linear => used only in recursive calls
 **
 * returns string similar to sha1, but lil bit more secure [=
 **/
function make_hash( $pass, $salt, $email, $linear=false ) {

    $numb = "";
    foreach( str_split($salt) as $char ) if( is_numeric( $char )) $numb .= $char;

    mt_srand( (int)$numb );
    $algs = array('whirlpool', 'sha512', 'sha384', 'ripemd320', 'snefru256', 'gost', 'snefru', 'ripemd256', 'sha256', 'sha224');

    // check if all algorithms are available
    foreach($algs as $hash) if(!in_array($hash,hash_algos())) throw new Exception("Unsupported algorithms.");

    $hash = $pass;
    foreach( str_split($salt) as $i => $char ) {

        $str = $hash . $char;

        if( $i%3 == 0 ) $str .= $email;
        if( $i%7 == 0 ) $str .= mt_rand( $hash );

        $hash = ( $linear ) ?
            hash( $algs[ $i%count($algs) ], $str, false ) :
            make_hash( $hash, $salt, $email, true );
    }
    return ( $linear ) ? $hash : sha1( $hash );
}
?>